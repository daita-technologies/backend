AWSTemplateFormatVersion: '2010-09-09'
Description: >
  AI-workers-app
Parameters:

  EC2KeyPair:
    Type: String
    Default: code_server_dev

  SecurityGroupIds:
    Type: CommaDelimitedList
    Default: 'sg-0c9a0ca7844d7b128,sg-00d8b4ca79ee1e42f,sg-007caf776eee9bd32,sg-04b9c865721337372,sg-0b411b5391db8d7a3'

  SubnetIds:
    Type: CommaDelimitedList
    Default: 'subnet-019da2a6738756f88,subnet-0642064673fd68d2e'

  VPCId:
    Type: String
    Default: vpc-057803c925fd8138a


  StagePara:
    Type: String
    Default: test
  ApplicationPara:
    Type: String
    Default: ecstask

  EFSAccessPointRootPath:
    Type: String
    Default: /ai-prepocessing-app-test

  EFSFileSystemId:
    Type:  String
    Default: fs-01115862a24b75423

  EFSAccessPoint:
    Type: String
    Default: fsap-0e97652d5a9ca4892
  ### Amid config: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-optimized_AMI.html
  AMIID: # for GPU 
    Type: String
    Default: ami-09cb4bc2dcc083845 #GPU

  InstanceType:
    Type: String
    Default: t3.xlarge

  SampleImage:
    Type: String
    Default: 737589818430.dkr.ecr.us-east-2.amazonaws.com/ai-services-repo:test-dowload-lib

  InternetGatewayID:
    Type: String
    Default: igw-05a5a3a33c9cfa1fc
  PrivateSubnetTwo:
    Type: String
    Default: subnet-0ea9f572789e618e8
  PrivateSubnetOne:
    Type: String
    Default: subnet-0c813a62097b52004
  # TestAutoScalingGroup:
  #   Type: String
  #   Default: dev1-daita-app-AICallerService-1VQZ8DN8SCKEI-ECSTasks-6USZ8DPRY96U-AutoScalingGroup-12CXKZ3AZAH65
  EC2InstanceRole:
    Type: String
    Default: dev1-daita-app-AICallerService-1VQ-ECSInstanceRole-MDOROY74HPWO
  # MyECSTaskRole:
  #   Type: String
  #   Default:
  
Resources:
  # Roles
  MyECSTaskExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
        - Effect: "Allow"
          Principal:
            Service: "ecs-tasks.amazonaws.com"
          Action:
          - "sts:AssumeRole"
      Policies:
        - PolicyName: 'AmazonECSTaskExecutionRolePolicy'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ecr:GetAuthorizationToken
                  - ecr:BatchCheckLayerAvailability
                  - ecr:GetDownloadUrlForLayer
                  - ecr:BatchGetImage
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                  - logs:CreateLogGroup
                Resource:
                  - "*"

  MyECSTaskRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
        - Effect: "Allow"
          Principal:
            Service: "ecs-tasks.amazonaws.com"
          Action:
          - "sts:AssumeRole"
      Policies:
        - PolicyName: 'AmazonS3FullAccess'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:*
                  - s3-object-lambda:*
                  - logs:*
                Resource:
                  - "*"

  # Role for the EC2 hosts. This allows the ECS agent on the EC2 hosts
  # to communciate with the ECS control plane, as well as download the docker
  # images from ECR to run on your host.
  # EC2InstanceRole:
  #   Type: AWS::IAM::Role
  #   Properties:
  #     AssumeRolePolicyDocument:
  #       Statement:
  #       - Effect: Allow
  #         Principal:
  #           Service: [ec2.amazonaws.com]
  #         Action: ['sts:AssumeRole']
  #     Path: /
  #     Policies:
  #     - PolicyName: ecs-service
  #       PolicyDocument:
  #         Statement:
  #         - Effect: Allow
  #           Action:
  #             - 'ecs:CreateCluster'
  #             - 'ecs:DeregisterContainerInstance'
  #             - 'ecs:DiscoverPollEndpoint'
  #             - 'ecs:Poll'
  #             - 'ecs:RegisterContainerInstance'
  #             - 'ecs:StartTelemetrySession'
  #             - 'ecs:Submit*'
  #             - 'logs:CreateLogStream'
  #             - 'logs:PutLogEvents'
  #             - 'ecr:GetAuthorizationToken'
  #             - 'ecr:BatchGetImage'
  #             - 'ecr:GetDownloadUrlForLayer'
  #             - 'ec2:DescribeTags'
  #             - 'logs:*'
  #             - 'ecr:*'
  #           Resource: '*'


  # Two public subnets, where containers can have public IP addresses
  # PublicSubnetOne:
  #   Type: AWS::EC2::Subnet
  #   Properties:
  #     Tags:
  #       - Key: "Name"
  #         Value: !Sub "${StagePara}_${ApplicationPara}_public_1"
  #     AvailabilityZone:
  #        Fn::Select:
  #        - 0
  #        - Fn::GetAZs: {Ref: 'AWS::Region'}
  #     VpcId: !Ref VPCId
  #     CidrBlock: !FindInMap ['SubnetConfig', 'PublicOne', 'CIDR']
  #     MapPublicIpOnLaunch: true

  # PublicSubnetTwo:
  #   Type: AWS::EC2::Subnet
  #   Properties:
  #     AvailabilityZone:
  #        Fn::Select:
  #        - 1
  #        - Fn::GetAZs: {Ref: 'AWS::Region'}
  #     VpcId: !Ref VPCId
  #     CidrBlock: !FindInMap ['SubnetConfig', 'PublicTwo', 'CIDR']
  #     MapPublicIpOnLaunch: true

  ###_____________ CREATE PRIVATE SUBNET __________________
  # Two private subnets where containers will only have private
  # IP addresses, and will only be reachable by other members of the
  # VPC
  # PrivateSubnetOne:
  #   Type: AWS::EC2::Subnet
  #   Properties:
  #     Tags:
  #       - Key: "Name"
  #         Value: !Sub "${StagePara}_${ApplicationPara}_private_sn_1"
  #     AvailabilityZone:
  #        Fn::Select:
  #        - 0
  #        - Fn::GetAZs: {Ref: 'AWS::Region'}
  #     VpcId: !Ref VPCId
  #     CidrBlock: !FindInMap ['SubnetConfig', 'PrivateOne', 'CIDR']
  # PrivateSubnetTwo:
  #   Type: AWS::EC2::Subnet
  #   Properties:
  #     Tags:
  #       - Key: "Name"
  #         Value: !Sub "${StagePara}_${ApplicationPara}_private_sn_2"
  #     AvailabilityZone:
  #        Fn::Select:
  #        - 1
  #        - Fn::GetAZs: {Ref: 'AWS::Region'}
  #     VpcId: !Ref VPCId
  #     CidrBlock: !FindInMap ['SubnetConfig', 'PrivateTwo', 'CIDR']

  ###___________________ NETWORKING SETUP FOR PRIVATE SUBNET ___________________
  # Setup networking resources for the private subnets. Containers
  # in these subnets have only private IP addresses, and must use a NAT
  # gateway to talk to the internet. We launch two NAT gateways, one for
  # each private subnet.
  # NatGatewayOneAttachment:
  #   Type: AWS::EC2::EIP
  #   Properties:
  #       Domain: vpc
  #       Tags:
  #         - Key: "Name"
  #           Value: !Sub "${StagePara}_${ApplicationPara}_eip_natgw_1_segment_nat"
  # NatGatewayTwoAttachment:
  #   Type: AWS::EC2::EIP
  #   Properties:
  #       Domain: vpc
  # NatGatewayOne:
  #   Type: AWS::EC2::NatGateway
  #   Properties:
  #     AllocationId: !GetAtt NatGatewayOneAttachment.AllocationId
  #     SubnetId: !Ref PublicSubnetOne
  # NatGatewayTwo:
  #   Type: AWS::EC2::NatGateway
  #   Properties:
  #     AllocationId: !GetAtt NatGatewayTwoAttachment.AllocationId
  #     SubnetId: !Ref PublicSubnetTwo
  # PrivateRouteTableOne:
  #   Type: AWS::EC2::RouteTable
  #   Properties:
  #     VpcId: !Ref VPCId
  # PrivateRouteOne:
  #   Type: AWS::EC2::Route
  #   Properties:
  #     RouteTableId: !Ref PrivateRouteTableOne
  #     DestinationCidrBlock: 0.0.0.0/0
  #     NatGatewayId: !Ref NatGatewayOne
  # PrivateRouteTableOneAssociation:
  #   Type: AWS::EC2::SubnetRouteTableAssociation
  #   Properties:
  #     RouteTableId: !Ref PrivateRouteTableOne
  #     SubnetId: !Ref PrivateSubnetOne
  # PrivateRouteTableTwo:
  #   Type: AWS::EC2::RouteTable
  #   Properties:
  #     VpcId: !Ref VPCId
  # PrivateRouteTwo:
  #   Type: AWS::EC2::Route
  #   Properties:
  #     RouteTableId: !Ref PrivateRouteTableTwo
  #     DestinationCidrBlock: 0.0.0.0/0
  #     NatGatewayId: !Ref NatGatewayOne
  # PrivateRouteTableTwoAssociation:
  #   Type: AWS::EC2::SubnetRouteTableAssociation
  #   Properties:
  #     RouteTableId: !Ref PrivateRouteTableTwo
  #     SubnetId: !Ref PrivateSubnetTwo


  ##______________ CONFIG VPC ENDPOINT ________________
  # VPC Endpoint for DynamoDB
  # If a container needs to access DynamoDB this allows a container in the private subnet
  # to talk to DynamoDB directly without needing to go via the NAT gateway. This reduces
  # the amount of bandwidth through the gateway, meaning that the gateway is free to serve
  # your other traffic.
  # link: https://aws.amazon.com/blogs/containers/using-vpc-endpoint-policies-to-control-amazon-ecr-access/
  # DynamoDBEndpoint:
  #   Type: AWS::EC2::VPCEndpoint
  #   Properties:
  #     PolicyDocument:
  #       Version: "2012-10-17"
  #       Statement:
  #         - Effect: Allow
  #           Action: "*"
  #           Principal: "*"
  #           Resource: "*"
  #     RouteTableIds:
  #       - !Ref 'PrivateRouteTableOne'
  #       - !Ref 'PrivateRouteTableTwo'
  #     ServiceName: !Sub com.amazonaws.${AWS::Region}.dynamodb
  #     VpcId: !Ref VPCId
  # S3VPCEndpoint:
  #   Type: AWS::EC2::VPCEndpoint
  #   Properties:
  #     PolicyDocument:
  #       Version: "2012-10-17"
  #       Statement:
  #         - Effect: Allow
  #           Action: "*"
  #           Principal: "*"
  #           Resource: "*"
  #     RouteTableIds:
  #       - !Ref 'PrivateRouteTableOne'
  #       - !Ref 'PrivateRouteTableTwo'
  #     ServiceName: !Sub com.amazonaws.${AWS::Region}.s3
  #     VpcId: !Ref VPCId
  # ECRPullImageEndpoint:
  #   Type: AWS::EC2::VPCEndpoint
  #   Properties:
  #     VpcEndpointType: Interface
  #     PolicyDocument:
  #       Version: "2012-10-17"
  #       Statement:
  #         - Effect: Allow
  #           Action: "*"
  #           Principal: "*"
  #           Resource: "*"
  #     ServiceName: !Sub com.amazonaws.${AWS::Region}.ecr.dkr
  #     VpcId: !Ref VPCId


  ###_____________ CLUSTER CONFIG ______________________
  # Create cluster and capacity for cluster
  ## docj: #https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ecs-capacityprovider-managedscaling.html
  AITaskECSCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: !Sub "${StagePara}-${ApplicationPara}-Cluster-AI-segment-tasks"


  ###________ CAPACITY CONFIG FOR CLUSTER ______________
  ###### doc: https://docs.aws.amazon.com/autoscaling/application/userguide/application-auto-scaling-target-tracking.html
  CapacityProvider:
    Type: AWS::ECS::CapacityProvider
    DependsOn: AITaskECSCluster
    Properties:
      Name: !Sub "${StagePara}-${ApplicationPara}-capacity-provider-segmentation"
      AutoScalingGroupProvider:
        AutoScalingGroupArn: !Ref TestAutoScalingGroup
        ManagedScaling:
          # InstanceWarmupPeriod: 300
          MaximumScalingStepSize: 2
          MinimumScalingStepSize: 1
          Status: ENABLED
          TargetCapacity: 100
        # ManagedTerminationProtection: ENABLED
  ClusterCapacityProviderAssociation:
    Type: AWS::ECS::ClusterCapacityProviderAssociations
    Properties:
      Cluster: !Ref AITaskECSCluster
      CapacityProviders:
        - !Ref CapacityProvider
      DefaultCapacityProviderStrategy:
        - CapacityProvider: !Ref CapacityProvider
          Weight: 1


  #_________________ CONFIG AUTO SCALING GROUP _____________
  # Auto scaling template
  # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-autoscaling.html
  # # for now we only create a one instance scaling group, the scaling base on SQS part might need to be done by cli as below
  TestAutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    DependsOn: AITaskECSCluster
    Properties:
      AutoScalingGroupName: !Sub "${StagePara}-${ApplicationPara}-ai-task-seg-autoscaling"
      VPCZoneIdentifier:
        - !Ref PrivateSubnetOne
        - !Ref PrivateSubnetTwo
      LaunchTemplate:
        LaunchTemplateId: !Ref EC2LaunchTemplate
        Version: !GetAtt EC2LaunchTemplate.LatestVersionNumber
      NewInstancesProtectedFromScaleIn: false #if true this block scale in termination completely
      MaxSize: 4
      MinSize: 0
      DesiredCapacity: 0  ### check link: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-as-group.html#cfn-as-group-desiredcapacity


  #_____________ EC2 CONFIG LAUNCH TEMPLATE ________________
  # A security group for the EC2 hosts that will run the containers.
  # Rules are added based on what ingress you choose to add to the cluster.
  ContainerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Access to the ECS hosts that run containers
      VpcId: !Ref VPCId
  ### config role for ec2
  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles: [!Ref EC2InstanceRole]
  # ## template config
  EC2LaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Properties:
      LaunchTemplateName: !Sub "${StagePara}-${ApplicationPara}-Ec2-Launch-template-segmentation-task"
      LaunchTemplateData:
        DisableApiTermination: false
        ImageId: !Ref AMIID
        InstanceType: !Ref InstanceType
        KeyName: !Ref EC2KeyPair
        SecurityGroupIds: [!Ref 'ContainerSecurityGroup']
        IamInstanceProfile:
          Arn: !GetAtt EC2InstanceProfile.Arn
        UserData:
          Fn::Base64: !Sub |
            #!/bin/bash -xe
            echo ECS_CLUSTER=${AITaskECSCluster} >> /etc/ecs/ecs.config
            yum install -y aws-cfn-bootstrap
            /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource TestAutoScalingGroup --region ${AWS::Region}

  # # # EFS
  # EFSAccessPoint:  # subnet must be one of EFSFileSystemId's Mount targets
  #   Type: AWS::EFS::AccessPoint
  #   Properties:
  #     FileSystemId: !Ref EFSFileSystemId
  #     PosixUser:
  #       Gid: "1000"
  #       Uid: "1000"
  #     RootDirectory:
  #       CreationInfo:
  #         OwnerGid: "1000"
  #         OwnerUid: "1000"
  #         Permissions: "777"
  #       Path: !Ref EFSAccessPointRootPath

  #____________________ TASK DEFINITION ________________
  # The task definition. This is a simple metadata description of what
  # container to run, and what resource requirements it has.
  MyWaitTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      ExecutionRoleArn: !Ref MyECSTaskExecutionRole
      TaskRoleArn: !Ref MyECSTaskRole
      NetworkMode: awsvpc
      ContainerDefinitions:
        -
          Name: !Sub "${StagePara}-${ApplicationPara}-AI-wait-task"
          Image: !Ref SampleImage
          Cpu: 256
          Memory: 256
          LogConfiguration:
            LogDriver: 'awslogs'
            Options:
              awslogs-group: !Sub ${StagePara}-service-${ApplicationPara}
              awslogs-region: !Ref 'AWS::Region'
              awslogs-create-group: true
              awslogs-stream-prefix: !Ref 'ApplicationPara'

  MyECSTaskLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/vendedlogs/states/${StagePara}-MyECSTaskLogGroup-${AWS::StackName}"
      RetentionInDays: 7

  AISegmentTask:
    Type: AWS::ECS::TaskDefinition
    Properties:
      ExecutionRoleArn: !Ref MyECSTaskExecutionRole
      TaskRoleArn: !Ref MyECSTaskRole #TODO: create this in template
      NetworkMode: awsvpc
      ContainerDefinitions:
        -
          Name: "ai-segment"
          Image: 737589818430.dkr.ecr.us-east-2.amazonaws.com/ai-services-repo:segformer
          Cpu: 2048
          Memory: 3072
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-region: !Sub "${AWS::Region}"
              awslogs-group: !Ref MyECSTaskLogGroup
              awslogs-stream-prefix: ai-segmentation
          MountPoints:
            -
              SourceVolume: "my-vol"
              ContainerPath: /app/data
      Volumes:
        -
          EFSVolumeConfiguration:
            AuthorizationConfig:
              AccessPointId: !Ref EFSAccessPoint
            FilesystemId: !Ref EFSFileSystemId
            TransitEncryption: ENABLED # enable this so maybe we don't need to config a access point https://docs.aws.amazon.com/pt_br/AWSCloudFormation/latest/UserGuide/aws-properties-ecs-taskdefinition-authorizationconfig.html
          Name: "my-vol"

  # AITaskECSLogGroup:
  #   Type: AWS::Logs::LogGroup
  #   Properties:
  #     LogGroupName: !Sub "/aws/vendedlogs/states/${AWS::StackName}-AITaskECSLogGroup"
  #     RetentionInDays: 7

  # ECS

Outputs:
  # ServerlessRestApi is an implicit API created out of Events key under Serverless::Function
  # Find out more about other implicit resources you can reference within SAM
  # https://github.com/awslabs/serverless-application-model/blob/master/docs/internals/generated_resources.rst#api
  AITaskECSClusterArn:
    Description: "ECS Cluster with EC2 provider"
    Value: !GetAtt AITaskECSCluster.Arn

  AITaskDefinitionArn:
    Description: "Task definition"
    Value: !Ref AISegmentTask
  MyWaitTaskDefinition:
    Value: !Ref MyWaitTaskDefinition
  # LsPrivateSubnetIDs:
  #   Value: !Join [ ",", [!Ref PrivateSubnetOne, !Ref PrivateSubnetTwo ] ]